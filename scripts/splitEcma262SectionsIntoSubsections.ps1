param(
    [Parameter(Mandatory = $false)]
    [string]$Root = ""
)

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

$Utf8NoBom = New-Object System.Text.UTF8Encoding($false)

function Write-Utf8NoBomLines([string]$path, [string[]]$lines) {
    [System.IO.File]::WriteAllLines($path, $lines, $Utf8NoBom)
}

if ([string]::IsNullOrWhiteSpace($Root)) {
    $Root = Join-Path $PSScriptRoot "..\docs\ECMA262"
}

$Root = (Resolve-Path -LiteralPath $Root).Path

$AutoGeneratedMarker = "<!-- AUTO-GENERATED: splitEcma262SectionsIntoSubsections.ps1 -->"

function Get-RollupStatus([string[]]$statuses) {
    $norm = $statuses | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne "" }

    if ($norm -contains "Not Yet Supported") { return "Not Yet Supported" }
    if ($norm -contains "Not Supported") { return "Not Yet Supported" }
    if ($norm -contains "Partially Supported") { return "Partially Supported" }
    if ($norm -contains "Supported") { return "Supported" }
    return "Untracked"
}

function Parse-TableRow([string]$line) {
    $parts = $line.Trim() -split '\|' | ForEach-Object { $_.Trim() }

    # line begins/ends with | so first/last are empty
    if ($parts.Count -lt 6) { return $null }

    return [pscustomobject]@{
        Clause = $parts[1]
        Title  = $parts[2]
        Status = $parts[3]
        Link   = $parts[4]
    }
}

function Find-LineIndex([string[]]$lines, [string]$needle) {
    for ($i = 0; $i -lt $lines.Length; $i++) {
        if ($lines[$i] -eq $needle) {
            return $i
        }
    }
    return -1
}

function Get-SubsectionDocTableRowCount([string]$path) {
    if (-not (Test-Path -LiteralPath $path)) { return 0 }

    $lines = Get-Content -LiteralPath $path
    $headerIndex = Find-LineIndex -lines $lines -needle "| Clause | Title | Status | Link |"
    if ($headerIndex -lt 0) { return 0 }

    $count = 0
    for ($i = $headerIndex + 2; $i -lt $lines.Count; $i++) {
        $l = $lines[$i]
        if (-not $l.Trim().StartsWith('|')) { continue }
        $r = Parse-TableRow $l
        if ($null -eq $r) { continue }
        $count++
    }
    return $count
}

function Should-OverwriteSubsectionDoc([string]$path) {
    if (-not (Test-Path -LiteralPath $path)) { return $true }

    $existing = Get-Content -LiteralPath $path -TotalCount 20
    if ($existing -contains $AutoGeneratedMarker) { return $true }

    # Heuristic for older auto-generated docs: allow overwrite only if the table is a stub (<= 1 data row).
    $rowCount = Get-SubsectionDocTableRowCount -path $path
    return ($rowCount -le 1)
}

$indexPath = Join-Path $Root "Index.md"
$sectionIndex = @{}

if (Test-Path -LiteralPath $indexPath) {
    $indexLines = Get-Content -LiteralPath $indexPath
    $sectionsHeaderIndex = Find-LineIndex -lines $indexLines -needle "| Section | Title | Status | Spec | Document |"
    if ($sectionsHeaderIndex -ge 0) {
        for ($i = $sectionsHeaderIndex + 2; $i -lt $indexLines.Count; $i++) {
            $line = $indexLines[$i]
            if (-not $line.Trim().StartsWith('|')) { continue }

            if ($line -match '^\|\s*(\d+)\s*\|') {
                $cells = $line -split '\|' | ForEach-Object { $_.Trim() }
                if ($cells.Count -ge 7) {
                    $n = $cells[1]
                    $title = $cells[2]
                    $spec = $cells[4]
                    $sectionIndex[$n] = [pscustomobject]@{ Title = $title; Spec = $spec }
                }
            }
        }
    }
}

$sectionFiles = Get-ChildItem -LiteralPath $Root -Filter "Section*.md" |
    Where-Object { $_.Name -match '^Section\d+\.md$' } |
    Sort-Object Name

$allSectionRollups = @{}

foreach ($file in $sectionFiles) {
    if ($file.Name -notmatch '^Section(\d+)\.md$') {
        continue
    }

    $sectionNumber = [int]$Matches[1]
    $lines = Get-Content -LiteralPath $file.FullName

    # If this section still has the full clause table, generate subsection docs.
    $tableHeaderIndex = Find-LineIndex -lines $lines -needle "| Clause | Title | Status | Link |"
    if ($tableHeaderIndex -ge 0) {
        $dataLines = @()
        for ($i = $tableHeaderIndex + 2; $i -lt $lines.Count; $i++) {
            $l = $lines[$i]
            if ($l.Trim().StartsWith('|')) {
                $dataLines += $l
            }
        }

        $rows = @()
        foreach ($dl in $dataLines) {
            $r = Parse-TableRow $dl
            if ($null -ne $r) {
                $rows += $r
            }
        }

        $hasChildClauses = ($rows | Where-Object { $_.Clause -match "^$sectionNumber\.\d+" } | Select-Object -First 1) -ne $null
        if ($hasChildClauses) {
            $subKeyToRows = @{}
            foreach ($r in $rows) {
                if ($r.Clause -match "^$sectionNumber\.(\d+)(\.|$)") {
                    $sub = $Matches[1]
                    if (-not $subKeyToRows.ContainsKey($sub)) { $subKeyToRows[$sub] = @() }
                    $subKeyToRows[$sub] += $r
                }
            }

            foreach ($sub in ($subKeyToRows.Keys | Sort-Object { [int]$_ })) {
                $subClause = "$sectionNumber.$sub"
                $subRows = @($rows | Where-Object { $_.Clause -eq $subClause -or $_.Clause -like "$subClause.*" })
                if ($subRows.Count -eq 0) { continue }

                $subTitleRow = $subRows | Where-Object { $_.Clause -eq $subClause } | Select-Object -First 1
                $subTitle = if ($subTitleRow) { $subTitleRow.Title } else { ($subRows | Select-Object -First 1).Title }

                $subPath = Join-Path $Root "Section${sectionNumber}_${sub}.md"

                if (-not (Should-OverwriteSubsectionDoc -path $subPath)) {
                    continue
                }

                $content = @()
                $content += $AutoGeneratedMarker
                $content += ""
                $content += "# Section ${subClause}: $subTitle"
                $content += ""
                $content += "[Back to Section$sectionNumber](Section$sectionNumber.md) | [Back to Index](Index.md)"
                $content += ""
                $content += "| Clause | Title | Status | Link |"
                $content += "|---:|---|---|---|"

                foreach ($sr in $subRows) {
                    $content += "| $($sr.Clause) | $($sr.Title) | $($sr.Status) | $($sr.Link) |"
                }

                Write-Utf8NoBomLines -path $subPath -lines $content
            }
        }
    }

    # If we have subsection docs, rebuild SectionN.md from them (idempotent)
    $subFiles = @(Get-ChildItem -LiteralPath $Root -Filter "Section${sectionNumber}_*.md" | Sort-Object Name)
    if ($subFiles.Count -eq 0) {
        continue
    }

    $lines = Get-Content -LiteralPath $file.FullName
    $backIndex = Find-LineIndex -lines $lines -needle "[Back to Index](Index.md)"
    $headerLines = if ($backIndex -ge 0) { $lines[0..$backIndex] } else { $lines[0..([Math]::Min(4, $lines.Count - 1))] }

    $sectionMeta = $sectionIndex["$sectionNumber"]
    $sectionTitle = if ($sectionMeta) { $sectionMeta.Title } else { "" }
    $sectionSpec = if ($sectionMeta) { $sectionMeta.Spec } else { "" }

    $subRowsForIndex = @()
    foreach ($sf in $subFiles) {
        if ($sf.Name -notmatch "^Section${sectionNumber}_(\d+)\.md$") { continue }
        $sub = $Matches[1]
        $subClause = "$sectionNumber.$sub"

        $subLines = Get-Content -LiteralPath $sf.FullName
        $subHeaderIndex = Find-LineIndex -lines $subLines -needle "| Clause | Title | Status | Link |"
        if ($subHeaderIndex -lt 0) { continue }

        $found = $null
        for ($i = $subHeaderIndex + 2; $i -lt $subLines.Count; $i++) {
            $l = $subLines[$i]
            if (-not $l.Trim().StartsWith('|')) { continue }
            $r = Parse-TableRow $l
            if ($null -eq $r) { continue }
            if ($r.Clause -eq $subClause) { $found = $r; break }
        }

        if ($null -ne $found) {
            $subRowsForIndex += [pscustomobject]@{ Sub = [int]$sub; Clause = $subClause; Title = $found.Title; Status = $found.Status; Link = $found.Link; File = $sf.Name }
        }
    }

    $subRowsForIndex = $subRowsForIndex | Sort-Object Sub
    $sectionRollupStatus = Get-RollupStatus ($subRowsForIndex | Select-Object -ExpandProperty Status)
    $allSectionRollups["$sectionNumber"] = $sectionRollupStatus

    $out = @()
    $out += $headerLines
    $out += ""
    $out += "_This section is split into subsection documents for readability._"
    $out += ""
    $out += "## Section Entry"
    $out += ""
    $out += "| Clause | Title | Status | Link |"
    $out += "|---:|---|---|---|"
    $out += "| $sectionNumber | $sectionTitle | $sectionRollupStatus | $sectionSpec |"
    $out += ""
    $out += "## Subsections"
    $out += ""
    $out += "| Subsection | Title | Status | Spec | Document |"
    $out += "|---:|---|---|---|---|"

    foreach ($sr in $subRowsForIndex) {
        $doc = "[$($sr.File)]($($sr.File))"
        $out += "| $($sr.Clause) | $($sr.Title) | $($sr.Status) | $($sr.Link) | $doc |"
    }

    Write-Utf8NoBomLines -path $file.FullName -lines $out
}

# Update Index.md section status column based on new rollups
if (Test-Path -LiteralPath $indexPath) {
    $indexLines = Get-Content -LiteralPath $indexPath
    $sectionsHeaderIndex = Find-LineIndex -lines $indexLines -needle "| Section | Title | Status | Spec | Document |"

    if ($sectionsHeaderIndex -ge 0) {
        for ($i = $sectionsHeaderIndex + 2; $i -lt $indexLines.Count; $i++) {
            $line = $indexLines[$i]
            if (-not $line.Trim().StartsWith('|')) { continue }

            if ($line -match '^\|\s*(\d+)\s*\|') {
                $n = $Matches[1]
                if (-not $allSectionRollups.ContainsKey($n)) { continue }

                $cells = $line -split '\|' | ForEach-Object { $_.Trim() }
                if ($cells.Count -ge 7) {
                    $cells[3] = $allSectionRollups[$n]
                    $indexLines[$i] = "| " + ($cells[1..5] -join " | ") + " |"
                }
            }
        }

        Write-Utf8NoBomLines -path $indexPath -lines $indexLines
    }
}

Write-Host "Split complete: subsection docs generated and indexes updated."
