/*
 * Generates docs/ECMA262/<section>/Section<section>_<sub>.json from the corresponding
 * markdown file if (and only if) the JSON file is missing.
 *
 * Safety:
 * - Never overwrites existing .json files.
 * - Defaults to dry-run unless --write is provided.
 *
 * Usage:
 *   node scripts/ECMA262/generateMissingEcma262SectionJson.js            # dry-run
 *   node scripts/ECMA262/generateMissingEcma262SectionJson.js --write    # write missing JSON files
 *   node scripts/ECMA262/generateMissingEcma262SectionJson.js --root docs/ECMA262 --write
 */

'use strict';

const fs = require('fs');
const path = require('path');

const DEFAULT_ROOT = path.resolve(__dirname, '..', '..', 'docs', 'ECMA262');

function parseArgs(argv) {
  const args = {
    root: DEFAULT_ROOT,
    write: false,
    verbose: false,
    help: false,
  };

  for (let i = 2; i < argv.length; i++) {
    const a = argv[i];

    if (a === '--help' || a === '-h') {
      args.help = true;
      continue;
    }

    if (a === '--write') {
      args.write = true;
      continue;
    }

    if (a === '--verbose' || a === '-v') {
      args.verbose = true;
      continue;
    }

    if (a === '--root' || a === '-r') {
      const v = argv[i + 1];
      if (v) {
        args.root = path.resolve(v);
        i++;
      }
      continue;
    }

    if (a.startsWith('--root=')) {
      args.root = path.resolve(a.substring('--root='.length));
      continue;
    }
  }

  return args;
}

function usage() {
  console.log('Generate missing ECMA-262 subsection JSON files from existing markdown.');
  console.log('');
  console.log('  node scripts/ECMA262/generateMissingEcma262SectionJson.js            # dry-run');
  console.log('  node scripts/ECMA262/generateMissingEcma262SectionJson.js --write    # create missing JSON files');
  console.log('');
  console.log('Options:');
  console.log('  --root, -r     Root docs folder (default: docs/ECMA262)');
  console.log('  --write        Actually write files (default: dry-run)');
  console.log('  --verbose, -v  Print parse details');
  console.log('  --help, -h     Show help');
}

function walkFiles(dir) {
  const out = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) {
      out.push(...walkFiles(full));
    } else if (e.isFile()) {
      out.push(full);
    }
  }
  return out;
}

function readText(filePath) {
  return fs.readFileSync(filePath, 'utf8');
}

function detectEol(text) {
  return text.includes('\r\n') ? '\r\n' : '\n';
}

function trimBom(text) {
  // Handle UTF-8 BOM at start of file.
  if (text.charCodeAt(0) === 0xfeff) {
    return text.slice(1);
  }
  return text;
}

function parseMarkdownLink(cellText) {
  // Matches [text](url)
  const m = /\[[^\]]*\]\(([^)]+)\)/.exec(cellText);
  if (!m) return null;
  return m[1].trim();
}

function parseTableRow(line) {
  // Very small markdown table parser: splits by | and trims.
  // Expects a line starting/ending with |.
  if (!line.trim().startsWith('|')) return null;
  const parts = line
    .trim()
    .replace(/^\|/, '')
    .replace(/\|$/, '')
    .split('|')
    .map((p) => p.trim());
  return parts;
}

function isSeparatorRow(line) {
  const t = line.trim();
  return t.startsWith('|') && t.includes('---');
}

function parseSectionDocFromMarkdown(mdPath, mdText, verbose) {
  const raw = trimBom(mdText);
  const eol = detectEol(raw);
  const lines = raw.split(/\r?\n/);

  const autoGeneratedHeader = lines.some((l) => l.startsWith('<!-- AUTO-GENERATED:'));

  const headerLine = lines.find((l) => /^#\s+Section\s+\d+\.\d+:\s+/.test(l));
  if (!headerLine) {
    throw new Error(`Missing '# Section X.Y: Title' heading in ${mdPath}`);
  }

  const headerMatch = /^#\s+Section\s+(\d+\.\d+):\s+(.+?)\s*$/.exec(headerLine);
  if (!headerMatch) {
    throw new Error(`Could not parse heading: '${headerLine}' in ${mdPath}`);
  }

  const clause = headerMatch[1].trim();
  const titleFromHeading = headerMatch[2].trim();

  // Parent backlink line: [Back to Section14](Section14.md) | [Back to Index](../Index.md)
  let parentClause = clause.split('.')[0];
  let parentDoc = `Section${parentClause}.md`;
  for (const l of lines) {
    const m = /\[Back to Section(\d+)\]\(([^)]+)\)/.exec(l);
    if (m) {
      parentClause = m[1];
      parentDoc = m[2];
      break;
    }
  }

  // Intro: content between backlink line and the first "| Clause |" table header.
  let intro = '';
  {
    const backIdx = lines.findIndex((l) => /\[Back to Section\d+\]/.test(l));
    const tableIdx = lines.findIndex((l) => /^\|\s*Clause\s*\|\s*Title\s*\|\s*Status\s*\|/i.test(l));
    if (backIdx !== -1 && tableIdx !== -1 && tableIdx > backIdx) {
      const chunk = lines
        .slice(backIdx + 1, tableIdx)
        .filter((l) => l.trim().length > 0)
        .filter((l) => !l.startsWith('<!-- AUTO-GENERATED:'))
        .join(eol)
        .trim();
      if (chunk.length > 0) intro = chunk;
    }
  }

  // Parse primary clause table to get title/status/specUrl.
  let status = null;
  let specUrl = null;
  {
    const tableHeaderIdx = lines.findIndex((l) => /^\|\s*Clause\s*\|\s*Title\s*\|\s*Status\s*\|/i.test(l));
    if (tableHeaderIdx === -1) {
      throw new Error(`Missing clause table in ${mdPath}`);
    }

    // Scan rows after separator.
    for (let i = tableHeaderIdx + 1; i < lines.length; i++) {
      const line = lines[i];
      if (!line.trim().startsWith('|')) break;
      if (isSeparatorRow(line)) continue;
      const row = parseTableRow(line);
      if (!row || row.length < 4) continue;
      if (row[0] !== clause) continue;

      // row: [clause, title, status, link]
      const rowTitle = row[1].trim();
      status = row[2].trim();
      specUrl = parseMarkdownLink(row[3]);

      // If heading title differs from table title, prefer table title (it tends to be canonical).
      if (rowTitle && rowTitle !== titleFromHeading && verbose) {
        console.log(`  note: title mismatch for ${clause}: heading='${titleFromHeading}', table='${rowTitle}'`);
      }

      break;
    }
  }

  if (!status || !specUrl) {
    throw new Error(`Could not find primary clause row for ${clause} in ${mdPath}`);
  }

  // Subclauses.
  const subclauses = [];
  {
    const subHeaderIdx = lines.findIndex((l) => /^##\s+Subclauses\s*$/i.test(l.trim()));
    if (subHeaderIdx !== -1) {
      const tableIdx = lines.findIndex(
        (l, idx) => idx > subHeaderIdx && /^\|\s*Clause\s*\|\s*Title\s*\|\s*Status\s*\|\s*Spec\s*\|/i.test(l)
      );
      if (tableIdx !== -1) {
        for (let i = tableIdx + 1; i < lines.length; i++) {
          const line = lines[i];
          if (!line.trim().startsWith('|')) break;
          if (isSeparatorRow(line)) continue;
          const row = parseTableRow(line);
          if (!row || row.length < 4) continue;
          const sc = row[0].trim();
          const st = row[1].trim();
          const ss = row[2].trim();
          const su = parseMarkdownLink(row[3]);
          if (!sc || !st || !ss || !su) continue;
          subclauses.push({ clause: sc, title: st, status: ss, specUrl: su });
        }
      }
    }
  }

  // Reference section.
  let reference = null;
  {
    const refIdx = lines.findIndex((l) => /^##\s+Reference:\s+Converted Spec Text\s*$/i.test(l.trim()));
    if (refIdx !== -1) {
      const windowLines = lines.slice(refIdx, Math.min(lines.length, refIdx + 200));
      const hasDetails = windowLines.some((l) => l.trim().toLowerCase() === '<details>');

      if (hasDetails) {
        // embedded mode
        const convertedLine = windowLines.find((l) => /Converted from `[^`]+`/i.test(l));
        const convertedFromHtmlMatch = convertedLine ? /Converted from `([^`]+)`/i.exec(convertedLine) : null;
        const convertedFromHtml = convertedFromHtmlMatch ? convertedFromHtmlMatch[1].trim() : null;

        const summaryLine = windowLines.find((l) => /<summary>.*<\/summary>/i.test(l));
        const detailsSummaryMatch = summaryLine ? /<summary>(.*?)<\/summary>/i.exec(summaryLine) : null;
        const detailsSummary = detailsSummaryMatch ? detailsSummaryMatch[1].trim() : null;

        const beginExtractLine = windowLines.find((l) => /BEGIN SPEC EXTRACT:/i.test(l));
        const specPathMatch = beginExtractLine ? /BEGIN SPEC EXTRACT:\s*(.+?)\s*-->/.exec(beginExtractLine) : null;
        const specMarkdownPath = specPathMatch ? specPathMatch[1].trim() : null;

        if (convertedFromHtml && specMarkdownPath) {
          reference = {
            mode: 'embedded',
            convertedFromHtml,
            specMarkdownPath,
          };
          if (detailsSummary) reference.detailsSummary = detailsSummary;
        } else {
          // Fallback to stub if we can't parse required fields.
          reference = {
            mode: 'stub',
            note: '_Intentionally not included here. Use the tc39.es links above as the normative reference._',
          };
        }
      } else {
        // stub mode
        const noteLine = windowLines.find((l) => l.trim().startsWith('_') && l.trim().endsWith('_'));
        reference = {
          mode: 'stub',
          note: noteLine ? noteLine.trim() : '_Intentionally not included here. Use the tc39.es links above as the normative reference._',
        };
      }
    }
  }

  const doc = {
    $schema: '../SectionDoc.schema.json',
    clause,
    title: titleFromHeading,
    status,
    specUrl,
    parent: {
      clause: parentClause,
    },
  };

  if (autoGeneratedHeader) doc.autoGeneratedHeader = true;
  if (parentDoc && parentDoc !== `Section${parentClause}.md`) {
    doc.parent.doc = parentDoc;
  }
  if (intro) doc.intro = intro;
  if (subclauses.length > 0) doc.subclauses = subclauses;
  if (reference) doc.reference = reference;

  return doc;
}

function main() {
  const args = parseArgs(process.argv);
  if (args.help) {
    usage();
    return;
  }

  if (!fs.existsSync(args.root) || !fs.statSync(args.root).isDirectory()) {
    console.error(`Root not found or not a directory: ${args.root}`);
    process.exitCode = 1;
    return;
  }

  const allFiles = walkFiles(args.root);
  const mdFiles = allFiles.filter((p) => p.endsWith('.md'));

  const pattern = /Section(\d+)_([0-9]+)\.md$/;

  let created = 0;
  let skippedExisting = 0;
  let skippedUnmatched = 0;
  let failed = 0;

  for (const mdPath of mdFiles) {
    const base = path.basename(mdPath);
    const m = pattern.exec(base);
    if (!m) {
      continue;
    }

    const dir = path.dirname(mdPath);
    const jsonPath = path.join(dir, base.replace(/\.md$/, '.json'));

    if (fs.existsSync(jsonPath)) {
      skippedExisting++;
      continue;
    }

    try {
      const mdText = readText(mdPath);
      const doc = parseSectionDocFromMarkdown(mdPath, mdText, args.verbose);

      // Extra safety: clause should match filename parent/sub.
      const expectedClause = `${m[1]}.${m[2]}`;
      if (doc.clause !== expectedClause) {
        skippedUnmatched++;
        console.warn(`skip: clause mismatch for ${path.relative(process.cwd(), mdPath)} (expected ${expectedClause}, got ${doc.clause})`);
        continue;
      }

      const jsonText = JSON.stringify(doc, null, 2) + '\n';
      const relJson = path.relative(process.cwd(), jsonPath);

      if (args.write) {
        // Never overwrite.
        if (fs.existsSync(jsonPath)) {
          skippedExisting++;
          continue;
        }

        fs.writeFileSync(jsonPath, jsonText, { encoding: 'utf8', flag: 'wx' });
        created++;
        console.log(`created: ${relJson}`);
      } else {
        console.log(`would create: ${relJson}`);
      }
    } catch (err) {
      failed++;
      console.error(`failed: ${path.relative(process.cwd(), mdPath)}: ${err && err.message ? err.message : String(err)}`);
    }
  }

  const mode = args.write ? 'write' : 'dry-run';
  console.log('');
  console.log(`Done (${mode}). created=${created}, skippedExisting=${skippedExisting}, skippedMismatch=${skippedUnmatched}, failed=${failed}`);

  if (failed > 0) {
    process.exitCode = 1;
  }
}

if (require.main === module) {
  main();
}
